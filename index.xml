<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Tech Blog</title><link>https://chrisjpalmer.github.io/</link><description>Recent content on Tech Blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sun, 04 Sep 2022 09:39:01 +1000</lastBuildDate><atom:link href="https://chrisjpalmer.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>Parallelism in Go - Part 1</title><link>https://chrisjpalmer.github.io/posts/parallelism_in_go_part_1/</link><pubDate>Sun, 04 Sep 2022 09:39:01 +1000</pubDate><guid>https://chrisjpalmer.github.io/posts/parallelism_in_go_part_1/</guid><description>Hi there! I wanted to make a blog post showing some of the cool things I have learnt about Go over the past 4 years. Its a great language and extremely practical for a plethora of backend tasks. With every release, the language just keeps getting better.
One of the things I have always been fascinated by with regards to computers was parallelism. Naturally when I started learning go, I made a point to check out all its concurrency features.</description></item><item><title>Parallelism in Go - Part 2</title><link>https://chrisjpalmer.github.io/posts/parallelism_in_go_part_2/</link><pubDate>Sun, 04 Sep 2022 09:39:01 +1000</pubDate><guid>https://chrisjpalmer.github.io/posts/parallelism_in_go_part_2/</guid><description>Hi there! This is a part twoer to my first post on Parallelism in Go. In my first post I explored parallelism with IO Bound Work - a particular type of workload which Go is very well designed to handle.
In this post I wanted to explore go&amp;rsquo;s parallelism characteristics around CPU Bound work. Now disclaimer: I went into this experiment fishing for a particular result, and I kind of only started to see it after a lot of testing&amp;hellip; I mean a lot.</description></item></channel></rss>