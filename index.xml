<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Tech Blog</title><link>https://chrisjpalmer.github.io/</link><description>Recent content on Tech Blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sun, 04 Sep 2022 09:39:01 +1000</lastBuildDate><atom:link href="https://chrisjpalmer.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>Parallelism in Go - Part 1</title><link>https://chrisjpalmer.github.io/posts/parallelism_in_go_part_1/</link><pubDate>Sun, 04 Sep 2022 09:39:01 +1000</pubDate><guid>https://chrisjpalmer.github.io/posts/parallelism_in_go_part_1/</guid><description>Hi there! I wanted to make a blog post showing some of the cool things I have learnt about Go over the past 4 years. Its a great language and extremely practical for a plethora of backend tasks. With every release, the language just keeps getting better.
One of the things I have always been fascinated by with regards to computers was parallelism. Naturally when I started learning go, I made a point to check out all its concurrency features.</description></item><item><title>Parallelism in Go - Part 2</title><link>https://chrisjpalmer.github.io/posts/parallelism_in_go_part_2/</link><pubDate>Sun, 04 Sep 2022 09:39:01 +1000</pubDate><guid>https://chrisjpalmer.github.io/posts/parallelism_in_go_part_2/</guid><description>Hi there! This is a part twoer to my first post on Parallelism in Go. In my last post I explored how goroutine workers can be used to complete IO bound work. The optimum number of goroutines to use is always aligned with the number of units of IO bound work. In this post I set out to explore another type of work which goroutine workers can be used to complete: CPU bound work.</description></item></channel></rss>