<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><title>Parallelism in Go - Part 1 | Tech Blog</title><meta name=viewport content="width=device-width,minimum-scale=1"><meta name=description content="Hi there! I wanted to make a blog post showing some of the cool things I have learnt about Go over the past 4 years. Its a great language and extremely practical for a plethora of backend tasks. With every release, the language just keeps getting better.
One of the things I have always been fascinated by with regards to computers was parallelism. Naturally when I started learning go, I made a point to check out all its concurrency features."><meta name=generator content="Hugo 0.102.3"><meta name=robots content="noindex, nofollow"><link rel=stylesheet href=/ananke/css/main.min.css><meta property="og:title" content="Parallelism in Go - Part 1"><meta property="og:description" content="Hi there! I wanted to make a blog post showing some of the cool things I have learnt about Go over the past 4 years. Its a great language and extremely practical for a plethora of backend tasks. With every release, the language just keeps getting better.
One of the things I have always been fascinated by with regards to computers was parallelism. Naturally when I started learning go, I made a point to check out all its concurrency features."><meta property="og:type" content="article"><meta property="og:url" content="https://chrisjpalmer.github.io/posts/parallelism_in_go/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-09-04T09:39:01+10:00"><meta property="article:modified_time" content="2022-09-04T09:39:01+10:00"><meta itemprop=name content="Parallelism in Go - Part 1"><meta itemprop=description content="Hi there! I wanted to make a blog post showing some of the cool things I have learnt about Go over the past 4 years. Its a great language and extremely practical for a plethora of backend tasks. With every release, the language just keeps getting better.
One of the things I have always been fascinated by with regards to computers was parallelism. Naturally when I started learning go, I made a point to check out all its concurrency features."><meta itemprop=datePublished content="2022-09-04T09:39:01+10:00"><meta itemprop=dateModified content="2022-09-04T09:39:01+10:00"><meta itemprop=wordCount content="1023"><meta itemprop=keywords content><meta name=twitter:card content="summary"><meta name=twitter:title content="Parallelism in Go - Part 1"><meta name=twitter:description content="Hi there! I wanted to make a blog post showing some of the cool things I have learnt about Go over the past 4 years. Its a great language and extremely practical for a plethora of backend tasks. With every release, the language just keeps getting better.
One of the things I have always been fascinated by with regards to computers was parallelism. Naturally when I started learning go, I made a point to check out all its concurrency features."></head><body class="ma0 avenir bg-near-white"><header><div class=bg-black><nav class="pv3 ph3 ph4-ns" role=navigation><div class="flex-l justify-between items-center center"><a href=/ class="f3 fw2 hover-white no-underline white-90 dib">Tech Blog</a><div class="flex-l items-center"><div class=ananke-socials></div></div></div></nav></div></header><main class=pb7 role=main><article class="flex-l flex-wrap justify-between mw8 center ph3"><header class="mt4 w-100"><aside class="instapaper_ignoref b helvetica tracked">POSTS</aside><div id=sharing class="mt3 ananke-socials"></div><h1 class="f1 athelas mt3 mb1">Parallelism in Go - Part 1</h1><time class="f6 mv4 dib tracked" datetime=2022-09-04T09:39:01+10:00>September 4, 2022</time></header><div class="nested-copy-line-height lh-copy serif f4 nested-links mid-gray pr4-l w-two-thirds-l"><p>Hi there! I wanted to make a blog post showing some of the cool things I have learnt about Go over the past 4 years.
Its a great language and extremely practical for a plethora of backend tasks. With every release, the language just keeps getting better.</p><p>One of the things I have always been fascinated by with regards to computers was parallelism. Naturally when I started learning go,
I made a point to check out all its concurrency features. And now I am writing a blog post on some of them! What&rsquo;s more, is that recently go 1.19 came out and it has support for generics! So what better way to showcase all this learning with some generic fun at the same time.</p><p>Below is an implementation of parallel doer that takes some array of work, fans it out to a set of workers and then collates the results:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>Do</span>[<span style=color:#a6e22e>I</span> <span style=color:#a6e22e>any</span>, <span style=color:#a6e22e>O</span> <span style=color:#a6e22e>any</span>](<span style=color:#a6e22e>work</span> []<span style=color:#a6e22e>I</span>, <span style=color:#a6e22e>workFunc</span> <span style=color:#a6e22e>WorkFunc</span>[<span style=color:#a6e22e>I</span>, <span style=color:#a6e22e>O</span>], <span style=color:#a6e22e>workers</span> <span style=color:#66d9ef>int</span>, <span style=color:#a6e22e>bufferSize</span> <span style=color:#66d9ef>int</span>) []<span style=color:#a6e22e>Result</span>[<span style=color:#a6e22e>I</span>, <span style=color:#a6e22e>O</span>] {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>workC</span> <span style=color:#f92672>:=</span> make(<span style=color:#66d9ef>chan</span> <span style=color:#a6e22e>I</span>, <span style=color:#a6e22e>bufferSize</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>resultC</span> <span style=color:#f92672>:=</span> make(<span style=color:#66d9ef>chan</span> <span style=color:#a6e22e>Result</span>[<span style=color:#a6e22e>I</span>, <span style=color:#a6e22e>O</span>], <span style=color:#a6e22e>bufferSize</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>results</span> <span style=color:#f92672>:=</span> make([]<span style=color:#a6e22e>Result</span>[<span style=color:#a6e22e>I</span>, <span style=color:#a6e22e>O</span>], <span style=color:#ae81ff>0</span>, len(<span style=color:#a6e22e>work</span>))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>wg</span> <span style=color:#a6e22e>sync</span>.<span style=color:#a6e22e>WaitGroup</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>wg</span>.<span style=color:#a6e22e>Add</span>(<span style=color:#a6e22e>workers</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#a6e22e>workers</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>go</span> <span style=color:#66d9ef>func</span>() {
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>defer</span> <span style=color:#a6e22e>wg</span>.<span style=color:#a6e22e>Done</span>()
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>w</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>workC</span> {
</span></span><span style=display:flex><span>				<span style=color:#a6e22e>o</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>workFunc</span>(<span style=color:#a6e22e>w</span>)
</span></span><span style=display:flex><span>				<span style=color:#a6e22e>resultC</span> <span style=color:#f92672>&lt;-</span> <span style=color:#a6e22e>Result</span>[<span style=color:#a6e22e>I</span>, <span style=color:#a6e22e>O</span>]{<span style=color:#a6e22e>w</span>, <span style=color:#a6e22e>o</span>, <span style=color:#a6e22e>err</span>}
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>		}()
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// load up the work
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>go</span> <span style=color:#66d9ef>func</span>() {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>defer</span> close(<span style=color:#a6e22e>workC</span>)
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>w</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>work</span> {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>workC</span> <span style=color:#f92672>&lt;-</span> <span style=color:#a6e22e>w</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// close results channel if all workers are done
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>go</span> <span style=color:#66d9ef>func</span>() {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>wg</span>.<span style=color:#a6e22e>Wait</span>()
</span></span><span style=display:flex><span>		close(<span style=color:#a6e22e>resultC</span>)
</span></span><span style=display:flex><span>	}()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// capture all results
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>r</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>resultC</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>results</span> = append(<span style=color:#a6e22e>results</span>, <span style=color:#a6e22e>r</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>results</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>If you like it you are most welcome to use it. You can find it <a href=https://github.com/chrisjpalmer/chrisjpalmer.github.io/tree/master/playground/parallelism_in_go/parallel/parallel.go>here</a>.</p><p>I have always been fascinated my Go&rsquo;s concurrency model. A friend once told me &ldquo;goroutines are faster than threads&rdquo;. I couldn&rsquo;t quite believe it at the time&mldr; <em>how can they be faster than threads?</em>. Upon further research I found that this statement wasn&rsquo;t quite true. Go routines run on threads so they themselves couldn&rsquo;t be <em>faster</em> than threads! What my friend was talking about though is the usefulness of goroutines for handling a particular workload type that appears commonly in web servers: IO bound work.</p><h2 id=io-bound-work>IO bound work</h2><p>IO bound operations are system calls, reads/writes to disk, or an http request&mldr; anything that your application isn&rsquo;t executing, but is <em>waiting</em> for it to complete.
For example, if your application fires an http request to <code>https://google.com</code>, it has to wait for the response from google. While its doing this, your application is idle and its not executing anything. Applications run on threads and when the thread becomes idle, the OS puts it to sleep and runs a different one. This helps to utilize the processor fully. The problem is that the threading model is heavy and switching between threads costs a lot of CPU cycles. The advantage of goroutines is that they are significantly lighter and context switching only comes with a small penalty. When a go application boots, it firstly spins up a small pool of threads (called logical processors) and constantly switches go routines on and off these threads, to keep the threads as busy as possible. In a web server where you deal predominantly with IO bound work, this is great. Thousands of goroutines can be spawned with a minimal performance penalty.</p><p>To show how smart I am, I wanted to demonstrate this for the blog post: I set up a test using the above parallel <code>Do</code> function.
The test creates 3000 units of work, runs <code>Do</code> and records how long it took. The test is run repeatedly and each time the workers are increased by 100.
To negate the effects of random interference on the machines I was testing, I ran each test 3 times and took the average of the results. For more good tips on how to take proper bench marks read <a href=https://dave.cheney.net/tag/benchmarking>Dave Cheney&rsquo;s blog post</a>&mldr; its really good!</p><p>My <code>Do</code> function requires a generic <code>WorkFunc</code> as an argument. This is the function it will call to &ldquo;get the work done&rdquo; on each worker. To simulate IO bound work, I constructed the simplest work function that waits 1 millisecond before returning. During that 1ms, the processor is doing nothing, simply waiting for time to pass so its a good candidate for IO bound work.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>BenchmarkDoIOBoundWork</span>(<span style=color:#a6e22e>b</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>testing</span>.<span style=color:#a6e22e>B</span>) {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>workUnits</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>3000</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>maxWorkers</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>6000</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>bufferSize</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>3000</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>work</span> <span style=color:#f92672>:=</span> make([]<span style=color:#66d9ef>uint64</span>, <span style=color:#a6e22e>workUnits</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>ws</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>ws</span> <span style=color:#f92672>&lt;=</span> <span style=color:#a6e22e>maxWorkers</span>; <span style=color:#a6e22e>ws</span> <span style=color:#f92672>+=</span> <span style=color:#ae81ff>100</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>_ws</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>ws</span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>_ws</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>_ws</span> = <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>Run</span>(<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Sprintf</span>(<span style=color:#e6db74>&#34;workers %d&#34;</span>, <span style=color:#a6e22e>_ws</span>), <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>b</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>testing</span>.<span style=color:#a6e22e>B</span>) {
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>N</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
</span></span><span style=display:flex><span>				<span style=color:#a6e22e>Do</span>(<span style=color:#a6e22e>work</span>, <span style=color:#a6e22e>ioBoundWorkFunc</span>, <span style=color:#a6e22e>_ws</span>, <span style=color:#a6e22e>bufferSize</span>)
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>		})
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// the work function
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>ioBoundWorkFunc</span>(<span style=color:#a6e22e>_</span> <span style=color:#66d9ef>uint64</span>) (<span style=color:#66d9ef>uint64</span>, <span style=color:#66d9ef>error</span>) {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Sleep</span>(<span style=color:#ae81ff>1</span> <span style=color:#f92672>*</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Millisecond</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>, <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Before I ran this function my hypothesis was that with 1 worker, <code>Do</code> would take (3000x1ms) 3s to complete all the work since each the work function would have to be run 3000 times one after the other. I hypothesized that as the workers increased to 3000, this value would approach <code>1ms</code> since all 3000 units of work were being run at the same time.
Here were the results:</p><p>Initially the <code>Do</code> takes roughly 4 seconds to complete.</p><p><img src=./io_bound_work_initially.png alt></p><p>As the workers increased to 3000, the time approached 3.5ms.
As the workers increased beyond 3000, the time increased slightly.</p><p><img src=./io_bound_work.png alt></p><p>I wasn&rsquo;t sure why the best result wasn&rsquo;t 1ms, but I guessed that some extra time was being added somewhere.
The fact that the time increased after 3000 workers made make sense to me though. Since there are only 3000 units of work in the test, there were no benefits after spinning up 3000 workers. The extra time was likely attributed to the cost of creating go routines and managing them on the scheduler.</p><p>Overall however, the results were what I wanted to see: You can spin up a large amount of goroutines with a minimal penalty to perform IO bound work.
Good job smart me!</p><p>But I didn&rsquo;t want to stop there&mldr;</p><h2 id=cpu-bound>CPU Bound</h2><ul class=pa0></ul><div class="mt6 instapaper_ignoref"></div></div><aside class="w-30-l mt6-l"></aside></article></main><footer class="bg-black bottom-0 w-100 pa3" role=contentinfo><div class="flex justify-between"><a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href=https://chrisjpalmer.github.io>&copy; Tech Blog 2022</a><div><div class=ananke-socials></div></div></div></footer></body></html>